package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"unicode/utf8"

	"github.com/davecgh/go-spew/spew"
	"github.com/ghodss/yaml"
	"github.com/seeruk/valley/constraints"
	"github.com/seeruk/valley/source"
	"github.com/seeruk/valley/valley"
)

func main() {
	if len(os.Args) < 3 {
		fmt.Println("valley: a package path, and a config file path must be given")
		os.Exit(1)
	}

	srcPath := os.Args[1]
	configPath := os.Args[2]

	file, err := os.Open(configPath)
	if err != nil {
		fmt.Printf("valley: failed to open config file: %q: %v\n", configPath, err)
		os.Exit(1)
	}

	defer file.Close()

	bs, err := ioutil.ReadAll(file)
	if err != nil {
		fmt.Printf("valley: failed to read config file: %q: %v\n", configPath, err)
		os.Exit(1)
	}

	var config valley.Config

	err = yaml.Unmarshal(bs, &config)
	if err != nil {
		fmt.Printf("valley: failed to unmarshal config: %q: %v\n", configPath, err)
		os.Exit(1)
	}

	reader := source.NewReader()

	pkg, err := reader.Read(srcPath)
	if err != nil {
		fmt.Printf("valley: failed to read structs in: %q: %v", srcPath, err)
		os.Exit(1)
	}

	fmt.Println("// Code generated by valley. DO NOT EDIT.")
	fmt.Printf("package %s\n", pkg.Name)
	fmt.Println()
	fmt.Println(`import "github.com/seeruk/valley/valley"`)

	for typeName, typ := range config.Types {
		s, ok := pkg.Structs[typeName]
		if !ok {
			continue
		}

		// Figure out an "okay" receiver name, based on the first letter of the type.
		firstRune, _ := utf8.DecodeRuneInString(typeName)
		receiver := strings.ToLower(string(firstRune))

		mm, ok := pkg.Methods[typeName]
		if ok && len(mm) > 0 {
			receiver = mm[0].Receiver
		}

		spew.Dump(mm)

		fmt.Println()
		fmt.Printf("func (%s %s) Validate() []valley.ConstraintViolation {\n", receiver, typeName)
		fmt.Println("	var violations []valley.ConstraintViolation")
		fmt.Println()
		fmt.Println("	path := valley.NewPath()")

		for fieldName, fieldConfig := range typ.Fields {
			f, ok := s.Fields[fieldName]
			if !ok {
				// TODO: Error, bad config
				fmt.Printf("valley: field %q does not exist in Go source", fieldName)
				continue
			}

			fmt.Printf("	path.Push(\"%s\")\n", fieldName)

			for _, constraintConfig := range fieldConfig.Constraints {
				constraint, ok := constraints.BuiltIn[constraintConfig.Name]
				if !ok {
					// TODO: Error, bad config.
					fmt.Printf("valley: unknown validation constraint: %q", constraintConfig.Name)
					continue
				}

				value := valley.Value{
					FieldName: fieldName,
					VarName:   fmt.Sprintf("%s.%s", receiver, fieldName),
				}

				code, err := constraint(value, f.Type, constraintConfig.Opts)
				if err != nil {
					// TODO: Error, invalid config.
					fmt.Printf("valley: failed to generate code for %q.%q's %q constraint: %v", typeName, fieldName, constraintConfig.Name, err)
					continue
				}

				fmt.Println(code)
			}

			fmt.Println("	path.Pop()")
			fmt.Println()
		}

		fmt.Println("	return violations")
		fmt.Printf("}\n")
	}
}
