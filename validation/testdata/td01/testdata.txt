Description: should successfully generate code given valid input

Generated:

// Code generated by valley. DO NOT EDIT.
package td01

import fmt "fmt"
import valley "github.com/seeruk/valley"
import reflect "reflect"
import regexp "regexp"
import strconv "strconv"
import time "time"

// Reference imports to suppress errors if they aren't otherwise used
var _ = fmt.Sprintf
var _ = strconv.Itoa

// Variables generated by constraints:
var github_com_seeruk_valley_validation_constraints_RegexpString_Testdata_39 = regexp.MustCompile("^Hello")
var github_com_seeruk_valley_validation_constraints_TimeStringAfter_Testdata_45 = valley.TimeMustParse(time.Parse(time.RFC3339, "2006-01-02"))
var github_com_seeruk_valley_validation_constraints_TimeStringBefore_Testdata_46 = valley.TimeMustParse(time.Parse(time.RFC3339, "2006-01-02"))

// Validate validates this SecondarySubject.
// This method was generated by Valley.
func (s SecondarySubject) Validate(path *valley.Path) []valley.ConstraintViolation {
	var violations []valley.ConstraintViolation

	path.Write(".")

	if s.SomeBool != true {
		size := path.Write("SomeBool")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "values must be equal",
			Details: map[string]interface{}{
				"equal_to": true,
			},
		})
		path.TruncateRight(size)
	}

	if s.SomePtr == nil {
		size := path.Write("SomePtr")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "value must not be nil",
		})
		path.TruncateRight(size)
	}

	if len(s.SomeText) == 0 {
		size := path.Write("SomeText")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "a value is required",
		})
		path.TruncateRight(size)
	}

	path.TruncateRight(1)

	return violations
}

// Validate validates this Subject.
// This method was generated by Valley.
func (s Subject) Validate(path *valley.Path) []valley.ConstraintViolation {
	var violations []valley.ConstraintViolation

	path.Write(".")

	{
		// AnyNRequired uses it's own block to lock down nonEmpty's scope.
		var nonEmpty []string

		if !(reflect.ValueOf(s.SomeBool).IsZero()) {
			nonEmpty = append(nonEmpty, "SomeBool")
		}

		if !(len(s.SomeMap) == 0) {
			nonEmpty = append(nonEmpty, "SomeMap")
		}

		if !(s.SomePtr == nil) {
			nonEmpty = append(nonEmpty, "SomePtr")
		}

		if !(len(s.SomeSlice) == 0) {
			nonEmpty = append(nonEmpty, "SomeSlice")
		}

		if !(len(s.SomeText) == 0) {
			nonEmpty = append(nonEmpty, "SomeText")
		}

		if len(nonEmpty) < 3 {

			violations = append(violations, valley.ConstraintViolation{
				Path:     path.String(),
				PathKind: "struct",
				Message:  "minimum number of required fields not met",
				Details: map[string]interface{}{
					"num_required": 3,
					"fields":       []string{"SomeBool", "SomeMap", "SomePtr", "SomeSlice", "SomeText"},
				},
			})

		}
	}

	{
		// ExactlyNRequired uses it's own block to lock down nonEmpty's scope.
		var nonEmpty []string

		if !(s.SomePtr == nil) {
			nonEmpty = append(nonEmpty, "SomePtr")
		}

		if !(len(s.SomeText) == 0) {
			nonEmpty = append(nonEmpty, "SomeText")
		}

		if len(nonEmpty) != 2 {

			violations = append(violations, valley.ConstraintViolation{
				Path:     path.String(),
				PathKind: "struct",
				Message:  "exact number of required fields not met",
				Details: map[string]interface{}{
					"num_required": 2,
					"fields":       []string{"SomePtr", "SomeText"},
				},
			})

		}
	}

	{
		// MutuallyExclusive uses it's own block to lock down nonEmpty's scope.
		var nonEmpty []string

		if !(len(s.SomeMap) == 0) {
			nonEmpty = append(nonEmpty, "SomeMap")
		}

		if !(len(s.SomeSlice) == 0) {
			nonEmpty = append(nonEmpty, "SomeSlice")
		}

		if len(nonEmpty) > 1 {

			violations = append(violations, valley.ConstraintViolation{
				Path:     path.String(),
				PathKind: "struct",
				Message:  "fields are mutually exclusive",
				Details: map[string]interface{}{
					"fields": nonEmpty,
				},
			})

		}
	}

	{
		// MutuallyInclusive uses it's own block to lock down nonEmpty's scope.
		var nonEmpty []string

		if !(s.SomePtr == nil) {
			nonEmpty = append(nonEmpty, "SomePtr")
		}

		if !(len(s.SomeText) == 0) {
			nonEmpty = append(nonEmpty, "SomeText")
		}

		if len(nonEmpty) > 0 && len(nonEmpty) != 2 {

			violations = append(violations, valley.ConstraintViolation{
				Path:     path.String(),
				PathKind: "struct",
				Message:  "fields are mutually inclusive",
				Details: map[string]interface{}{
					"fields": []string{"SomePtr", "SomeText"},
				},
			})

		}
	}

	if s.Secondary != nil {
		size := path.Write("Secondary")
		violations = append(violations, s.Secondary.Validate(path)...)
		path.TruncateRight(size)
	}

	if !reflect.DeepEqual(s.SomeBool, true) {
		size := path.Write("SomeBool")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "values must be deeply equal",
			Details: map[string]interface{}{
				"deeply_equal_to": true,
			},
		})
		path.TruncateRight(size)
	}

	if s.SomeBool != true {
		size := path.Write("SomeBool")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "values must be equal",
			Details: map[string]interface{}{
				"equal_to": true,
			},
		})
		path.TruncateRight(size)
	}

	if s.SomeBool == false {
		size := path.Write("SomeBool")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "values must not be equal",
			Details: map[string]interface{}{
				"equal_to": false,
			},
		})
		path.TruncateRight(size)
	}

	if s.SomeChan != nil {
		size := path.Write("SomeChan")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "value must be nil",
		})
		path.TruncateRight(size)
	}

	if s.SomeChan == nil {
		size := path.Write("SomeChan")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "value must not be nil",
		})
		path.TruncateRight(size)
	}

	if len(s.SomeMap) == 0 {
		size := path.Write("SomeMap")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "a value is required",
		})
		path.TruncateRight(size)
	}

	if len(s.SomeMap) < 1 {
		size := path.Write("SomeMap")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "minimum length not met",
			Details: map[string]interface{}{
				"minimum": 1,
			},
		})
		path.TruncateRight(size)
	}

	if s.SomeMap != nil {
		size := path.Write("SomeMap")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "value must be nil",
		})
		path.TruncateRight(size)
	}

	if s.SomeMap == nil {
		size := path.Write("SomeMap")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "value must not be nil",
		})
		path.TruncateRight(size)
	}

	for i, element := range s.SomeMap {

		if element == 0 {
			size := path.Write("SomeMap.[" + fmt.Sprintf("%v", i) + "]")
			violations = append(violations, valley.ConstraintViolation{
				Path:     path.String(),
				PathKind: "element",
				Message:  "a value is required",
			})
			path.TruncateRight(size)
		}

		if element < 1 {
			size := path.Write("SomeMap.[" + fmt.Sprintf("%v", i) + "]")
			violations = append(violations, valley.ConstraintViolation{
				Path:     path.String(),
				PathKind: "element",
				Message:  "minimum value not met",
				Details: map[string]interface{}{
					"minimum": 1,
				},
			})
			path.TruncateRight(size)
		}

	}

	for key := range s.SomeMap {

		if len(key) == 0 {
			size := path.Write("SomeMap.[" + fmt.Sprintf("%v", key) + "]")
			violations = append(violations, valley.ConstraintViolation{
				Path:     path.String(),
				PathKind: "key",
				Message:  "a value is required",
			})
			path.TruncateRight(size)
		}

		if len(key) < 3 {
			size := path.Write("SomeMap.[" + fmt.Sprintf("%v", key) + "]")
			violations = append(violations, valley.ConstraintViolation{
				Path:     path.String(),
				PathKind: "key",
				Message:  "minimum length not met",
				Details: map[string]interface{}{
					"minimum": 3,
				},
			})
			path.TruncateRight(size)
		}

	}

	if s.SomePtr == nil {
		size := path.Write("SomePtr")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "a value is required",
		})
		path.TruncateRight(size)
	}

	if s.SomePtr != nil {
		size := path.Write("SomePtr")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "value must be nil",
		})
		path.TruncateRight(size)
	}

	if s.SomePtr == nil {
		size := path.Write("SomePtr")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "value must not be nil",
		})
		path.TruncateRight(size)
	}

	if s.SomeBool {

		if s.SomePtr != nil {
			size := path.Write("SomePtr")
			violations = append(violations, valley.ConstraintViolation{
				Path:     path.String(),
				PathKind: "field",
				Message:  "value must be nil",
			})
			path.TruncateRight(size)
		}

		if s.SomePtr == nil {
			size := path.Write("SomePtr")
			violations = append(violations, valley.ConstraintViolation{
				Path:     path.String(),
				PathKind: "field",
				Message:  "value must not be nil",
			})
			path.TruncateRight(size)
		}

	}

	if len(s.SomeSlice) == 0 {
		size := path.Write("SomeSlice")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "a value is required",
		})
		path.TruncateRight(size)
	}

	if len(s.SomeSlice) != 16 {
		size := path.Write("SomeSlice")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "exact length not met",
			Details: map[string]interface{}{
				"exactly": 16,
			},
		})
		path.TruncateRight(size)
	}

	if len(s.SomeSlice) < 2 {
		size := path.Write("SomeSlice")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "minimum length not met",
			Details: map[string]interface{}{
				"minimum": 2,
			},
		})
		path.TruncateRight(size)
	}

	if len(s.SomeSlice) > 128 {
		size := path.Write("SomeSlice")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "maximum length exceeded",
			Details: map[string]interface{}{
				"maximum": 128,
			},
		})
		path.TruncateRight(size)
	}

	if s.SomeSlice != nil {
		size := path.Write("SomeSlice")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "value must be nil",
		})
		path.TruncateRight(size)
	}

	if s.SomeSlice == nil {
		size := path.Write("SomeSlice")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "value must not be nil",
		})
		path.TruncateRight(size)
	}

	for i, element := range s.SomeSlice {

		if len(element) == 0 {
			size := path.Write("SomeSlice.[" + strconv.Itoa(i) + "]")
			violations = append(violations, valley.ConstraintViolation{
				Path:     path.String(),
				PathKind: "element",
				Message:  "a value is required",
			})
			path.TruncateRight(size)
		}

		if len(element) != 8 {
			size := path.Write("SomeSlice.[" + strconv.Itoa(i) + "]")
			violations = append(violations, valley.ConstraintViolation{
				Path:     path.String(),
				PathKind: "element",
				Message:  "exact length not met",
				Details: map[string]interface{}{
					"exactly": 8,
				},
			})
			path.TruncateRight(size)
		}

		if len(element) < 2 {
			size := path.Write("SomeSlice.[" + strconv.Itoa(i) + "]")
			violations = append(violations, valley.ConstraintViolation{
				Path:     path.String(),
				PathKind: "element",
				Message:  "minimum length not met",
				Details: map[string]interface{}{
					"minimum": 2,
				},
			})
			path.TruncateRight(size)
		}

		if len(element) > 32 {
			size := path.Write("SomeSlice.[" + strconv.Itoa(i) + "]")
			violations = append(violations, valley.ConstraintViolation{
				Path:     path.String(),
				PathKind: "element",
				Message:  "maximum length exceeded",
				Details: map[string]interface{}{
					"maximum": 32,
				},
			})
			path.TruncateRight(size)
		}

	}

	if len(s.SomeText) == 0 {
		size := path.Write("SomeText")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "a value is required",
		})
		path.TruncateRight(size)
	}

	if !patternGreeting.MatchString(s.SomeText) {
		size := path.Write("SomeText")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "value must match regular expression",
			Details: map[string]interface{}{
				"regexp": patternGreeting.String(),
			},
		})
		path.TruncateRight(size)
	}

	if !github_com_seeruk_valley_validation_constraints_RegexpString_Testdata_39.MatchString(s.SomeText) {
		size := path.Write("SomeText")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "value must match regular expression",
			Details: map[string]interface{}{
				"regexp": github_com_seeruk_valley_validation_constraints_RegexpString_Testdata_39.String(),
			},
		})
		path.TruncateRight(size)
	}

	if s.SomeText != "Hello, World!" && s.SomeText != "Hello, Go!" {
		size := path.Write("SomeText")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "value must be one of the allowed values",
			Details: map[string]interface{}{
				"allowed": []interface{}{"Hello, World!", "Hello, Go!"},
			},
		})
		path.TruncateRight(size)
	}

	if 1 == 1 {
		size := path.Write("SomeText")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "\"1 must equal 1\"",
		})
		path.TruncateRight(size)
	}

	if reflect.ValueOf(s.SomeTime).IsZero() {
		size := path.Write("SomeTime")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "a value is required",
		})
		path.TruncateRight(size)
	}

	if !s.SomeTime.After(time.Now()) {
		size := path.Write("SomeTime")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "value must be after time",
			Details: map[string]interface{}{
				"time": time.Now().Format(time.RFC3339),
			},
		})
		path.TruncateRight(size)
	}

	if !s.SomeTime.Before(time.Now()) {
		size := path.Write("SomeTime")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "value must be before time",
			Details: map[string]interface{}{
				"time": time.Now().Format(time.RFC3339),
			},
		})
		path.TruncateRight(size)
	}

	if !s.SomeTime.After(github_com_seeruk_valley_validation_constraints_TimeStringAfter_Testdata_45) {
		size := path.Write("SomeTime")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "value must be after time",
			Details: map[string]interface{}{
				"time": github_com_seeruk_valley_validation_constraints_TimeStringAfter_Testdata_45.Format(time.RFC3339),
			},
		})
		path.TruncateRight(size)
	}

	if !s.SomeTime.Before(github_com_seeruk_valley_validation_constraints_TimeStringBefore_Testdata_46) {
		size := path.Write("SomeTime")
		violations = append(violations, valley.ConstraintViolation{
			Path:     path.String(),
			PathKind: "field",
			Message:  "value must be before time",
			Details: map[string]interface{}{
				"time": github_com_seeruk_valley_validation_constraints_TimeStringBefore_Testdata_46.Format(time.RFC3339),
			},
		})
		path.TruncateRight(size)
	}

	path.TruncateRight(1)

	return violations
}

Error:

(interface {}) <nil>
