package validation

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"sort"
	"strings"
	"unicode/utf8"

	"github.com/seeruk/valley/validation/constraints"
	"github.com/seeruk/valley/valley"
)

// Generator is a type used to generate validation code.
type Generator struct {
	cb   *bytes.Buffer
	ipts map[valley.Import]struct{}
}

// NewGenerator returns a new Generator instance.
func NewGenerator() *Generator {
	return &Generator{
		cb:   &bytes.Buffer{},
		ipts: make(map[valley.Import]struct{}),
	}
}

// Generate ...
func (g *Generator) Generate(config valley.Config, pkg valley.Package) (io.Reader, error) {
	typeNames := make([]string, 0, len(config.Types))
	for typeName := range config.Types {
		typeNames = append(typeNames, typeName)
	}

	// Ensure we generate methods in the same order each time.
	sort.Strings(typeNames)

	for _, typeName := range typeNames {
		typ := config.Types[typeName]

		s, ok := pkg.Structs[typeName]
		if !ok {
			continue
		}

		// Figure out an "okay" receiver name, based on the first letter of the type.
		firstRune, _ := utf8.DecodeRuneInString(typeName)
		receiver := strings.ToLower(string(firstRune))

		mm, ok := pkg.Methods[typeName]
		if ok && len(mm) > 0 {
			receiver = mm[0].Receiver
		}

		g.wc("// Validate validates this %s.\n", typeName)
		g.wc("// This method was generated by Valley.\n")
		g.wc("func (%s %s) Validate() []valley.ConstraintViolation {\n", receiver, typeName)
		g.wc("	var violations []valley.ConstraintViolation\n")
		g.wc("\n")
		g.wc("	path := valley.NewPath()\n")

		fieldNames := make([]string, 0, len(typ.Fields))
		for fieldName := range typ.Fields {
			fieldNames = append(fieldNames, fieldName)
		}

		// Ensure that each field's validation is generated in the same order each time.
		sort.Strings(fieldNames)

		for _, fieldName := range fieldNames {
			fieldConfig := typ.Fields[fieldName]

			f, ok := s.Fields[fieldName]
			if !ok {
				return nil, fmt.Errorf("valley: field %q does not exist in Go source", fieldName)
			}

			value := valley.Value{
				TypeName:  typeName,
				Receiver:  receiver,
				FieldName: fieldName,
				VarName:   fmt.Sprintf("%s.%s", receiver, fieldName),
			}

			err := g.generateField(value, fieldConfig, f)
			if err != nil {
				// TODO: Wrap?
				return nil, err
			}
		}

		g.wc("	return violations\n")
		g.wc("}\n\n")
	}

	buf := &bytes.Buffer{}

	fmt.Fprintln(buf, "// Code generated by valley. DO NOT EDIT.")
	fmt.Fprintf(buf, "package %s\n", pkg.Name)
	fmt.Fprintln(buf)
	fmt.Fprintln(buf, "import \"github.com/seeruk/valley/valley\"")

	for ipt := range g.ipts {
		if ipt.Alias != "" {
			fmt.Fprintf(buf, "import %s \"%s\"\n", ipt.Alias, ipt.Path)
		} else {
			fmt.Fprintf(buf, "import \"%s\"\n", ipt.Path)
		}
	}

	fmt.Fprintln(buf)

	_, err := io.Copy(buf, g.cb)
	if err != nil {
		return nil, errors.New("failed to copy code buffer contents to generate buffer")
	}

	return buf, nil
}

// generateField generates all of the code for a specific field.
func (g *Generator) generateField(value valley.Value, fieldConfig valley.FieldConfig, field valley.Field) error {
	g.wc("	path.Push(\"%s\")\n", value.FieldName)

	for _, constraintConfig := range fieldConfig.Constraints {
		constraint, ok := constraints.BuiltIn[constraintConfig.Name]
		if !ok {
			return fmt.Errorf("valley: unknown validation constraint: %q", constraintConfig.Name)
		}

		output, err := constraint(value, field.Type, constraintConfig.Opts)
		if err != nil {
			return fmt.Errorf("valley: failed to generate code for %q.%q's %q constraint: %v",
				value.TypeName, value.FieldName, constraintConfig.Name, err)
		}

		for _, ipt := range output.Imports {
			g.ipts[ipt] = struct{}{}
		}

		g.wc(output.Code)
		g.wc("\n")
	}

	g.wc("	path.Pop()\n")
	g.wc("\n")

	return nil
}

// wc writes code to the code buffer.
func (g *Generator) wc(format string, a ...interface{}) {
	fmt.Fprintf(g.cb, format, a...)
}
