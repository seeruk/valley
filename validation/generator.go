package validation

import (
	"bytes"
	"fmt"
	"io"
	"strings"
	"unicode/utf8"

	"github.com/seeruk/valley/validation/constraints"
	"github.com/seeruk/valley/valley"
)

// Generator is a type used to generate validation code.
type Generator struct {
	// ...
}

// NewGenerator returns a new Generator instance.
func NewGenerator() *Generator {
	return &Generator{}
}

// Generate ...
func (g *Generator) Generate(config valley.Config, pkg valley.Package) io.Reader {
	buf := &bytes.Buffer{}

	fmt.Fprintln(buf, "// Code generated by valley. DO NOT EDIT.")
	fmt.Fprintf(buf, "package %s\n", pkg.Name)
	fmt.Fprintln(buf)
	fmt.Fprintln(buf, `import "github.com/seeruk/valley/valley"`)

	for typeName, typ := range config.Types {
		s, ok := pkg.Structs[typeName]
		if !ok {
			continue
		}

		// Figure out an "okay" receiver name, based on the first letter of the type.
		firstRune, _ := utf8.DecodeRuneInString(typeName)
		receiver := strings.ToLower(string(firstRune))

		mm, ok := pkg.Methods[typeName]
		if ok && len(mm) > 0 {
			receiver = mm[0].Receiver
		}

		fmt.Fprintln(buf)
		fmt.Fprintf(buf, "func (%s %s) Validate() []valley.ConstraintViolation {\n", receiver, typeName)
		fmt.Fprintln(buf, "	var violations []valley.ConstraintViolation")
		fmt.Fprintln(buf)
		fmt.Fprintln(buf, "	path := valley.NewPath()")

		for fieldName, fieldConfig := range typ.Fields {
			f, ok := s.Fields[fieldName]
			if !ok {
				// TODO: Error, bad config
				fmt.Fprintf(buf, "valley: field %q does not exist in Go source", fieldName)
				continue
			}

			fmt.Fprintf(buf, "	path.Push(\"%s\")\n", fieldName)

			for _, constraintConfig := range fieldConfig.Constraints {
				constraint, ok := constraints.BuiltIn[constraintConfig.Name]
				if !ok {
					// TODO: Error, bad config.
					fmt.Fprintf(buf, "valley: unknown validation constraint: %q", constraintConfig.Name)
					continue
				}

				value := valley.Value{
					FieldName: fieldName,
					VarName:   fmt.Sprintf("%s.%s", receiver, fieldName),
				}

				code, err := constraint(value, f.Type, constraintConfig.Opts)
				if err != nil {
					// TODO: Error, invalid config.
					fmt.Fprintf(buf, "valley: failed to generate code for %q.%q's %q constraint: %v", typeName, fieldName, constraintConfig.Name, err)
					continue
				}

				fmt.Fprintln(buf, code)
			}

			fmt.Fprintln(buf, "	path.Pop()")
			fmt.Fprintln(buf)
		}

		fmt.Fprintln(buf, "	return violations")
		fmt.Fprintf(buf, "}\n")
	}

	return buf
}
