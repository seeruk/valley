package validation

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"strings"
	"unicode/utf8"

	"github.com/seeruk/valley/validation/constraints"
	"github.com/seeruk/valley/valley"
)

// Generator is a type used to generate validation code.
type Generator struct {
	cb *bytes.Buffer
	ib *bytes.Buffer
}

// NewGenerator returns a new Generator instance.
func NewGenerator() *Generator {
	return &Generator{
		cb: &bytes.Buffer{},
		ib: &bytes.Buffer{},
	}
}

// Generate ...
func (g *Generator) Generate(config valley.Config, pkg valley.Package) (io.Reader, error) {
	g.wi("github.com/seeruk/valley/valley", "")

	for typeName, typ := range config.Types {
		s, ok := pkg.Structs[typeName]
		if !ok {
			continue
		}

		// Figure out an "okay" receiver name, based on the first letter of the type.
		firstRune, _ := utf8.DecodeRuneInString(typeName)
		receiver := strings.ToLower(string(firstRune))

		mm, ok := pkg.Methods[typeName]
		if ok && len(mm) > 0 {
			receiver = mm[0].Receiver
		}

		g.wc("// Validate validates this %s.\n", typeName)
		g.wc("// This method was generated by Valley.\n")
		g.wc("func (%s %s) Validate() []valley.ConstraintViolation {\n", receiver, typeName)
		g.wc("	var violations []valley.ConstraintViolation\n")
		g.wc("\n")
		g.wc("	path := valley.NewPath()\n")

		for fieldName, fieldConfig := range typ.Fields {
			f, ok := s.Fields[fieldName]
			if !ok {
				// TODO: Error, bad config
				g.wc("valley: field %q does not exist in Go source", fieldName)
				continue
			}

			g.wc("	path.Push(\"%s\")\n", fieldName)

			for _, constraintConfig := range fieldConfig.Constraints {
				constraint, ok := constraints.BuiltIn[constraintConfig.Name]
				if !ok {
					// TODO: Error, bad config.
					g.wc("valley: unknown validation constraint: %q", constraintConfig.Name)
					continue
				}

				value := valley.Value{
					FieldName: fieldName,
					VarName:   fmt.Sprintf("%s.%s", receiver, fieldName),
				}

				code, err := constraint(value, f.Type, constraintConfig.Opts)
				if err != nil {
					// TODO: Error, invalid config.
					g.wc("valley: failed to generate code for %q.%q's %q constraint: %v", typeName, fieldName, constraintConfig.Name, err)
					continue
				}

				g.wc(code)
				g.wc("\n")
			}

			g.wc("	path.Pop()\n")
			g.wc("\n")
		}

		g.wc("	return violations\n")
		g.wc("}\n")
	}

	buf := &bytes.Buffer{}

	fmt.Fprintln(buf, "// Code generated by valley. DO NOT EDIT.")
	fmt.Fprintf(buf, "package %s\n", pkg.Name)
	fmt.Fprintln(buf)

	_, err := io.Copy(buf, g.ib)
	if err != nil {
		return nil, errors.New("failed to copy imports buffer contents to generate buffer")
	}

	fmt.Fprintln(buf)

	_, err = io.Copy(buf, g.cb)
	if err != nil {
		return nil, errors.New("failed to copy code buffer contents to generate buffer")
	}

	return buf, nil
}

// wc writes code to the code buffer.
func (g *Generator) wc(format string, a ...interface{}) {
	fmt.Fprintf(g.cb, format, a...)
}

// wi writes an import to the import buffer.
func (g *Generator) wi(ipt, alias string) {
	if alias != "" {
		fmt.Fprintf(g.ib, "import %s \"%s\"\n", alias, ipt)
	} else {
		fmt.Fprintf(g.ib, "import \"%s\"\n", ipt)
	}
}
