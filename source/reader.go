package source

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"strings"

	"github.com/seeruk/valley/valley"
)

// Reader is a type used to read Go source code, and return information that Valley needs to then
// generate validation code.
type Reader struct {
	// ...
}

// NewReader returns a new Reader instance.
func NewReader() *Reader {
	return &Reader{}
}

// Read attempts to read a Go package, and based on it's contents return the package name, along
// with an extract of information about the structs in that package.
func (r *Reader) Read(pkgPath string) (valley.Package, error) {
	pkg := valley.Package{
		Methods: make(valley.Methods),
		Structs: make(valley.Structs),
	}

	gopkg, err := r.readPackage(pkgPath)
	if err != nil {
		// TODO: Wrap.
		return pkg, err
	}

	pkg.Name = gopkg.Name

	for _, f := range gopkg.Files {
		methods, structs := r.readFile(f)

		for name, m := range methods {
			pkg.Methods[name] = append(pkg.Methods[name], m...)
		}

		for name, s := range structs {
			pkg.Structs[name] = s
		}
	}

	return pkg, nil
}

// readPackage attempts to get the non-test package in the given directory.
func (r *Reader) readPackage(pkgPath string) (*ast.Package, error) {
	pkgs, err := parser.ParseDir(token.NewFileSet(), pkgPath, nil, parser.ParseComments)
	if err != nil {
		// TODO: Wrapping?
		return nil, err
	}

	for _, pkg := range pkgs {
		if !strings.HasSuffix(pkg.Name, "_test") {
			return pkg, nil
		}
	}

	return nil, fmt.Errorf("valley: unable to find non-test Go package in %q", pkgPath)
}

// readFile reads information about the structs in a given file.
func (r *Reader) readFile(f *ast.File) (valley.Methods, valley.Structs) {
	methods := make(valley.Methods)
	structs := make(valley.Structs)

	// We need to skip files that are generated by valley, they may affect generated code.
	if f.Doc != nil && len(f.Doc.List) > 0 {
		for _, docComment := range f.Doc.List {
			if strings.Contains(docComment.Text, "Code generated by valley") {
				return methods, structs
			}
		}
	}

	if len(f.Decls) > 0 {
		for _, decl := range f.Decls {
			// TODO: Split into multiple methods.
			switch d := decl.(type) {
			case *ast.FuncDecl:
				if d.Recv == nil {
					continue
				}

				// This should probably never happen.
				if len(d.Recv.List) != 1 {
					continue
				}

				receiver := d.Recv.List[0]
				receiverName := receiver.Names[0].Name
				receiverType := unpackStarExpr(receiver.Type)

				switch t := receiverType.(type) {
				case *ast.Ident:
					methods[t.Name] = append(methods[t.Name], valley.Method{
						Receiver: receiverName,
						Name:     d.Name.Name,
					})
				}

			case *ast.GenDecl:
				if d.Tok != token.TYPE {
					continue
				}

				for _, spec := range d.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}

					structType, ok := typeSpec.Type.(*ast.StructType)
					if !ok {
						continue
					}

					// At this point, we definitely have a struct.
					structName := typeSpec.Name.Name
					structs[structName] = valley.Struct{
						Name:   structName,
						Node:   structType,
						Fields: r.readStructFields(structType),
					}
				}
			}
		}
	}

	return methods, structs
}

// readStructFields reads information about the fields on a given struct type, returning them in a
// more easily accessible format, with only the information we need.
func (r *Reader) readStructFields(structType *ast.StructType) valley.Fields {
	fields := make(valley.Fields)

	for _, field := range structType.Fields.List {
		for _, name := range field.Names {
			fields[name.Name] = valley.Value{
				Name: name.Name,
				Type: field.Type,
			}
		}
	}

	return fields
}

// unpackStarExpr ...
func unpackStarExpr(expr ast.Expr) ast.Expr {
	se, ok := expr.(*ast.StarExpr)
	if !ok {
		return expr
	}

	result := se.X
	if se, ok = result.(*ast.StarExpr); ok {
		return unpackStarExpr(se)
	}

	return result
}
