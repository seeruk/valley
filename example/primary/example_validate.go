// Code generated by valley. DO NOT EDIT.
package primary

import "strconv"
import "github.com/seeruk/valley/valley"

// Validate validates this Example.
// This method was generated by Valley.
func (e Example) Validate() []valley.ConstraintViolation {
	var violations []valley.ConstraintViolation

	path := valley.NewPath()

	if len(e.Ints) == 0 {
		size := path.Write(".Ints")

		violations = append(violations, valley.ConstraintViolation{
			Field:   path.String(),
			Message: "a value is required",
		})

		path.TruncateRight(size)
	}

	for i, element := range e.Ints {

		if element == 0 {
			size := path.Write(".Ints.[" + strconv.Itoa(i) + "]")

			violations = append(violations, valley.ConstraintViolation{
				Field:   path.String(),
				Message: "a value is required",
			})

			path.TruncateRight(size)
		}

	}

	if len(e.Text) == 0 {
		size := path.Write(".Text")

		violations = append(violations, valley.ConstraintViolation{
			Field:   path.String(),
			Message: "a value is required",
		})

		path.TruncateRight(size)
	}

	if len(e.TextMap) == 0 {
		size := path.Write(".TextMap")

		violations = append(violations, valley.ConstraintViolation{
			Field:   path.String(),
			Message: "a value is required",
		})

		path.TruncateRight(size)
	}

	return violations
}

// Validate validates this NestedExample.
// This method was generated by Valley.
func (n NestedExample) Validate() []valley.ConstraintViolation {
	var violations []valley.ConstraintViolation

	path := valley.NewPath()

	if len(n.Text) == 0 {
		size := path.Write(".Text")

		violations = append(violations, valley.ConstraintViolation{
			Field:   path.String(),
			Message: "a value is required",
		})

		path.TruncateRight(size)
	}

	return violations
}
