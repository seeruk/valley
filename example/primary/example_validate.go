// Code generated by valley. DO NOT EDIT.
package primary

import "strconv"
import "github.com/seeruk/valley/valley"

// Validate validates this Example.
// This method was generated by Valley.
func (e Example) Validate() []valley.ConstraintViolation {
	var violations []valley.ConstraintViolation

	path := valley.NewPath()
	path.Push("Ints")

	if len(e.Ints) == 0 {
		violations = append(violations, valley.ConstraintViolation{
			Field:   path.Render(),
			Message: "a value is required",
		})
	}

	for i, element := range e.Ints {
		path.Push("[" + strconv.Itoa(i) + "]")

		if element == 0 {
			violations = append(violations, valley.ConstraintViolation{
				Field:   path.Render(),
				Message: "a value is required",
			})
		}

		path.Pop()
	}

	path.Pop()

	path.Push("Text")

	if len(e.Text) == 0 {
		violations = append(violations, valley.ConstraintViolation{
			Field:   path.Render(),
			Message: "a value is required",
		})
	}

	path.Pop()

	path.Push("TextMap")

	if len(e.TextMap) == 0 {
		violations = append(violations, valley.ConstraintViolation{
			Field:   path.Render(),
			Message: "a value is required",
		})
	}

	path.Pop()

	return violations
}

// Validate validates this NestedExample.
// This method was generated by Valley.
func (n NestedExample) Validate() []valley.ConstraintViolation {
	var violations []valley.ConstraintViolation

	path := valley.NewPath()
	path.Push("Text")

	if len(n.Text) == 0 {
		violations = append(violations, valley.ConstraintViolation{
			Field:   path.Render(),
			Message: "a value is required",
		})
	}

	path.Pop()

	return violations
}
