//go:generate sh -c "valley . ./primary.valley.yml > primary_validate.go"
package primary

import (
	"strconv"

	"github.com/seeruk/valley/example/secondary"
	"github.com/seeruk/valley/valley"
)

// Example ...
type Example struct {
	Text      string              `json:"text"`
	Texts     []string            `json:"texts"`
	TextMap   map[string]string   `json:"text_map"`
	Int       int                 `json:"int"`
	Ints      []int               `json:"ints"`
	Nested    NestedExample       `json:"nested"`
	Secondary secondary.Secondary `json:"secondary"`
}

// Bla ...
func (e *Example) Bla() {}

// Validate validates this Example.
// This method was generated by Valley.
func (e Example) ValidateBuffer() []valley.ConstraintViolation {
	var violations []valley.ConstraintViolation

	path := valley.NewPath()

	if len(e.Ints) == 0 {
		size := path.Write(".Ints")

		violations = append(violations, valley.ConstraintViolation{
			Field:   path.Render(),
			Message: "a value is required",
		})

		path.TruncateRight(size)
	}

	for i, element := range e.Ints {
		if element == 0 {
			size := path.Write(".Ints.[" + strconv.Itoa(i) + "]")

			violations = append(violations, valley.ConstraintViolation{
				Field:   path.Render(),
				Message: "a value is required",
			})

			path.TruncateRight(size)
		}
	}

	if len(e.Text) == 0 {
		size := path.Write(".Text")

		violations = append(violations, valley.ConstraintViolation{
			Field:   path.Render(),
			Message: "a value is required",
		})

		path.TruncateRight(size)
	}

	if len(e.TextMap) == 0 {
		size := path.Write(".TextMap")

		violations = append(violations, valley.ConstraintViolation{
			Field:   path.Render(),
			Message: "a value is required",
		})

		path.TruncateRight(size)
	}

	return violations
}

// NestedExample ...
type NestedExample struct {
	Text string `json:"text"`
}
